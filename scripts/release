#!/usr/bin/env -S uv run --script --quiet
# /// script
# requires-python = ">=3.12"
# dependencies = []
# ///
"""create a github release using timestamp-based versioning

version format: YYYY.MMDD.HHMMSS (e.g., 2025.1106.134523)

usage:
    just release
    ./scripts/release
"""

import subprocess
import sys
from datetime import UTC, datetime


def main() -> int:
    """create release with timestamp version."""
    # ensure we're on main branch
    result = subprocess.run(
        ["git", "branch", "--show-current"],
        capture_output=True,
        text=True,
        check=True,
    )
    current_branch = result.stdout.strip()

    if current_branch != "main":
        print(f"âŒ must be on main branch (currently on {current_branch})")
        return 1

    # ensure working directory is clean
    result = subprocess.run(
        ["git", "status", "--porcelain"],
        capture_output=True,
        text=True,
        check=True,
    )
    if result.stdout.strip():
        print("âŒ working directory has uncommitted changes")
        return 1

    # ensure we're up to date with remote
    subprocess.run(["git", "fetch"], capture_output=True, check=True)
    result = subprocess.run(
        ["git", "rev-list", "HEAD..@{u}"],
        capture_output=True,
        text=True,
        check=True,
    )
    if result.stdout.strip():
        print("âŒ local branch is behind remote - please pull first")
        return 1

    # check if there are backend changes since last release
    result = subprocess.run(
        ["gh", "release", "list", "--limit", "1"],
        capture_output=True,
        text=True,
        check=True,
    )
    if result.stdout.strip():
        last_release = result.stdout.split()[0]

        # check for backend changes since last release
        result = subprocess.run(
            ["git", "log", f"{last_release}..HEAD", "--oneline", "--", "backend/src/backend/"],
            capture_output=True,
            text=True,
            check=True,
        )

        if not result.stdout.strip():
            print("âŒ no backend changes since last release")
            print(f"   last release: {last_release}")
            print("   only frontend/docs changes do not require a backend release")
            return 1

    version = datetime.now(UTC).strftime("%Y.%m%d.%H%M%S")

    # print banner using figlet
    subprocess.run(["figlet", "-f", "small", "plyr.fm"], check=False)
    print("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
    print(f"release  {version}")
    print("target   production")
    print("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

    # create release - gh will auto-generate notes from commits
    subprocess.run(
        [
            "gh",
            "release",
            "create",
            version,
            "--title",
            version,
            "--generate-notes",
        ],
        check=True,
    )

    print(f"\nâœ“ release {version} created")
    print("âœ“ production backend deployment starting...")

    # merge main -> production-fe to trigger frontend deployment
    print("\nðŸ”„ updating production-fe branch...")
    subprocess.run(["git", "fetch", "origin"], check=True)
    subprocess.run(["git", "checkout", "production-fe"], check=True)
    subprocess.run(["git", "merge", "main", "--ff-only"], check=True)
    subprocess.run(["git", "push", "origin", "production-fe"], check=True)
    subprocess.run(["git", "checkout", "main"], check=True)

    print("âœ“ production frontend deployment starting...")

    # mirror to tangled
    subprocess.run(["git", "push", "tangled", "main", "--tags"], check=True)
    print("âœ“ mirrored to tangled")

    return 0


if __name__ == "__main__":
    sys.exit(main())
