#!/usr/bin/env -S uv run --script --quiet
# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "atproto @ git+https://github.com/zzstoatzz/atproto@main",
#     "pydantic-settings>=2.7.0",
#     "rich>=13.0.0",
# ]
# ///
"""crud operations for atproto records."""

import argparse
import asyncio
import os
import sys
import warnings
from datetime import UTC, datetime
from pathlib import Path

warnings.filterwarnings("ignore")
os.environ["PYTHONWARNINGS"] = "ignore"

from atproto import AsyncClient
from pydantic import Field
from pydantic_settings import BaseSettings, SettingsConfigDict
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.table import Table

console = Console()


class Settings(BaseSettings):
    """settings for atproto cli."""

    model_config = SettingsConfigDict(
        env_file=str(Path(__file__).resolve().parents[1] / ".env"),
        env_file_encoding="utf-8",
        extra="ignore",
        case_sensitive=False,
    )

    atproto_app_namespace: str = Field(default="fm.plyr")
    atproto_old_app_namespace: str | None = Field(default=None)
    atproto_pds_url: str = Field(default="https://bsky.social")
    notify_bot_handle: str = Field(default="")
    notify_bot_password: str = Field(default="")


settings = Settings()

# silence httpx logs
import logging

logging.getLogger("httpx").setLevel(logging.CRITICAL)


def get_collection(collection: str | None = None, use_old: bool = False) -> str:
    """get the collection name to use."""
    if collection:
        return collection
    if use_old:
        if not settings.atproto_old_app_namespace:
            console.print("[red]error:[/red] no old namespace configured")
            sys.exit(1)
        return f"{settings.atproto_old_app_namespace}.track"
    return f"{settings.atproto_app_namespace}.track"


async def login() -> AsyncClient:
    """authenticate using bot credentials."""
    if not settings.notify_bot_handle or not settings.notify_bot_password:
        console.print(
            "[red]error:[/red] NOTIFY_BOT_HANDLE and NOTIFY_BOT_PASSWORD required"
        )
        sys.exit(1)

    with Progress(
        SpinnerColumn(),
        TextColumn("[dim]{task.description}"),
        console=console,
        transient=True,
    ) as progress:
        progress.add_task("authenticating...", total=None)
        client = AsyncClient(base_url=settings.atproto_pds_url)
        await client.login(settings.notify_bot_handle, settings.notify_bot_password)

    console.print(f"[dim]✓ authenticated as[/dim] {settings.notify_bot_handle}\n")
    return client


async def cmd_list(client: AsyncClient, collection: str, limit: int) -> None:
    """list records in a collection."""
    if client.me is None:
        raise ValueError("not authenticated")

    response = await client.com.atproto.repo.list_records(
        {
            "repo": client.me.did,
            "collection": collection,
            "limit": limit,
        }
    )

    if not response.records:
        console.print(f"[dim]no records found in {collection}[/dim]")
        return

    table = Table(
        title=f"{collection} ({len(response.records)} records)",
        show_header=True,
        header_style="bold cyan",
    )
    table.add_column("title", style="white")
    table.add_column("artist", style="yellow")
    table.add_column("uri", style="dim", overflow="fold")

    for record in response.records:
        value = record.value if hasattr(record, "value") else record["value"]
        # value could be a dict or an object
        if isinstance(value, dict):
            title = value.get("title", "")
            artist = value.get("artist", "")
        else:
            title = getattr(value, "title", "")
            artist = getattr(value, "artist", "")
        table.add_row(title, artist, record.uri)

    console.print(table)


async def cmd_get(client: AsyncClient, uri: str) -> None:
    """get a specific record."""
    parts = uri.replace("at://", "").split("/")
    if len(parts) != 3:
        console.print(f"[red]error:[/red] invalid URI format: {uri}")
        sys.exit(1)

    repo, collection, rkey = parts

    response = await client.com.atproto.repo.get_record(
        {
            "repo": repo,
            "collection": collection,
            "rkey": rkey,
        }
    )

    table = Table(show_header=False, box=None)
    table.add_column("key", style="cyan")
    table.add_column("value", style="white")

    table.add_row("uri", response.uri)
    table.add_row("cid", response.cid)

    for key, value in response.value.items():
        if key != "$type":
            table.add_row(key, str(value))

    console.print(Panel(table, title="[bold]record details[/bold]", border_style="dim"))


async def cmd_create(
    client: AsyncClient,
    collection: str,
    title: str,
    artist: str,
    audio_url: str,
    file_type: str,
    album: str | None = None,
    duration: int | None = None,
) -> None:
    """create a new track record."""
    if client.me is None:
        raise ValueError("not authenticated")

    record = {
        "$type": collection,
        "title": title,
        "artist": artist,
        "audioUrl": audio_url,
        "fileType": file_type,
        "createdAt": datetime.now(UTC).isoformat().replace("+00:00", "Z"),
    }

    if album:
        record["album"] = album
    if duration:
        record["duration"] = duration

    response = await client.com.atproto.repo.create_record(
        {
            "repo": client.me.did,
            "collection": collection,
            "record": record,
        }
    )

    console.print(
        Panel(
            f"[green]✓[/green] created\n\n[dim]uri:[/dim] {response.uri}\n[dim]cid:[/dim] {response.cid}",
            title=f"[bold]{title}[/bold]",
            border_style="green",
        )
    )


async def cmd_update(client: AsyncClient, uri: str, **updates) -> None:
    """update an existing record."""
    parts = uri.replace("at://", "").split("/")
    if len(parts) != 3:
        console.print(f"[red]error:[/red] invalid URI format")
        sys.exit(1)

    repo, collection, rkey = parts

    # get current record
    current = await client.com.atproto.repo.get_record(
        {
            "repo": repo,
            "collection": collection,
            "rkey": rkey,
        }
    )

    # merge updates
    updated_value = dict(current.value)
    for key, value in updates.items():
        if value is not None:
            updated_value[key] = value

    # put updated record
    response = await client.com.atproto.repo.put_record(
        {
            "repo": repo,
            "collection": collection,
            "rkey": rkey,
            "record": updated_value,
        }
    )

    console.print(
        Panel(
            f"[green]✓[/green] updated\n\n[dim]uri:[/dim] {response.uri}\n[dim]cid:[/dim] {response.cid}",
            border_style="green",
        )
    )


async def cmd_delete(client: AsyncClient, uri: str) -> None:
    """delete a record."""
    parts = uri.replace("at://", "").split("/")
    if len(parts) != 3:
        console.print(f"[red]error:[/red] invalid URI format")
        sys.exit(1)

    repo, collection, rkey = parts

    await client.com.atproto.repo.delete_record(
        {
            "repo": repo,
            "collection": collection,
            "rkey": rkey,
        }
    )

    console.print(Panel("[green]✓[/green] deleted", border_style="red"))


async def main() -> int:
    """main entry point."""
    parser = argparse.ArgumentParser(description="crud operations for atproto records")

    subparsers = parser.add_subparsers(dest="command", help="command to execute")

    # list
    list_parser = subparsers.add_parser("list", help="list records")
    list_parser.add_argument("--collection", help="collection name")
    list_parser.add_argument("--old", action="store_true", help="use old namespace")
    list_parser.add_argument("--limit", type=int, default=100, help="max records")

    # get
    get_parser = subparsers.add_parser("get", help="get record")
    get_parser.add_argument("--uri", required=True, help="record URI")

    # create
    create_parser = subparsers.add_parser("create", help="create record")
    create_parser.add_argument("--title", required=True)
    create_parser.add_argument("--artist", required=True)
    create_parser.add_argument("--audio-url", required=True)
    create_parser.add_argument("--file-type", required=True)
    create_parser.add_argument("--album")
    create_parser.add_argument("--duration", type=int)
    create_parser.add_argument("--collection")
    create_parser.add_argument("--old", action="store_true", help="use old namespace")

    # update
    update_parser = subparsers.add_parser("update", help="update record")
    update_parser.add_argument("--uri", required=True)
    update_parser.add_argument("--title")
    update_parser.add_argument("--artist")
    update_parser.add_argument("--album")
    update_parser.add_argument("--audio-url")

    # delete
    delete_parser = subparsers.add_parser("delete", help="delete record")
    delete_parser.add_argument("--uri", required=True)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    try:
        client = await login()

        if args.command == "list":
            collection = get_collection(args.collection, args.old)
            await cmd_list(client, collection, args.limit)

        elif args.command == "get":
            await cmd_get(client, args.uri)

        elif args.command == "create":
            collection = get_collection(args.collection, args.old)
            await cmd_create(
                client,
                collection,
                args.title,
                args.artist,
                args.audio_url,
                args.file_type,
                args.album,
                args.duration,
            )

        elif args.command == "update":
            updates = {}
            if args.title:
                updates["title"] = args.title
            if args.artist:
                updates["artist"] = args.artist
            if args.album:
                updates["album"] = args.album
            if args.audio_url:
                updates["audioUrl"] = args.audio_url

            await cmd_update(client, args.uri, **updates)

        elif args.command == "delete":
            await cmd_delete(client, args.uri)

        return 0

    except Exception as e:
        console.print(f"[red]error:[/red] {e}")
        if os.getenv("DEBUG"):
            raise
        return 1


if __name__ == "__main__":
    sys.exit(asyncio.run(main()))
