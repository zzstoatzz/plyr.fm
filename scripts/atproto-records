#!/usr/bin/env -S uv run --script --quiet
# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "atproto @ git+https://github.com/zzstoatzz/atproto@main",
#     "pydantic-settings>=2.7.0",
#     "rich>=13.0.0",
# ]
# ///
"""general-purpose cli for atproto record operations."""

import argparse
import asyncio
import os
import sys
import warnings
from datetime import UTC, datetime
from pathlib import Path

warnings.filterwarnings("ignore")
os.environ["PYTHONWARNINGS"] = "ignore"

from atproto import AsyncClient
from pydantic import Field
from pydantic_settings import BaseSettings, SettingsConfigDict
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.table import Table

console = Console()


class Settings(BaseSettings):
    """settings for atproto cli."""

    model_config = SettingsConfigDict(
        env_file=str(Path(__file__).resolve().parents[1] / ".env"),
        env_file_encoding="utf-8",
        extra="ignore",
        case_sensitive=False,
    )

    atproto_pds_url: str = Field(default="https://bsky.social")
    atproto_handle: str = Field(default="")
    atproto_password: str = Field(default="")


settings = Settings()

# silence httpx logs
import logging

logging.getLogger("httpx").setLevel(logging.CRITICAL)


async def login(handle: str | None = None, password: str | None = None) -> AsyncClient:
    """authenticate with atproto."""
    auth_handle = handle or settings.atproto_handle
    auth_password = password or settings.atproto_password

    if not auth_handle or not auth_password:
        console.print(
            "[red]error:[/red] provide --handle/--password or set ATPROTO_HANDLE/ATPROTO_PASSWORD"
        )
        sys.exit(1)

    with Progress(
        SpinnerColumn(),
        TextColumn("[dim]{task.description}"),
        console=console,
        transient=True,
    ) as progress:
        progress.add_task("authenticating...", total=None)
        client = AsyncClient(base_url=settings.atproto_pds_url)
        await client.login(auth_handle, auth_password)

    console.print(f"[dim]✓ authenticated as[/dim] {auth_handle}\n")
    return client


async def cmd_list(
    client: AsyncClient, collection: str, limit: int, repo: str | None = None
) -> None:
    """list records in a collection."""
    target_repo = repo or (client.me.did if client.me else None)
    if not target_repo:
        raise ValueError("no repo specified and not authenticated")

    response = await client.com.atproto.repo.list_records(
        {
            "repo": target_repo,
            "collection": collection,
            "limit": limit,
        }
    )

    if not response.records:
        console.print(f"[dim]no records in {collection}[/dim]")
        return

    table = Table(
        title=f"{collection} ({len(response.records)} records)",
        show_header=True,
        header_style="bold cyan",
    )
    table.add_column("rkey", style="dim", width=15)

    # dynamically add columns based on first record
    if response.records:
        first_value = response.records[0].value
        if isinstance(first_value, dict):
            for key in first_value.keys():
                if key != "$type":
                    table.add_column(key, style="white")
        else:
            # object - try to convert to dict first
            if hasattr(first_value, "to_dict"):
                first_value = first_value.to_dict()
                for key in first_value.keys():
                    if key != "$type":
                        table.add_column(key, style="white")
            else:
                # fallback to attributes
                for key in dir(first_value):
                    if (
                        not key.startswith("_")
                        and key not in ["py_type", "model_config"]
                        and not callable(getattr(first_value, key))
                    ):
                        table.add_column(key, style="white")

    for record in response.records:
        # extract rkey from uri
        rkey = record.uri.split("/")[-1]

        value = record.value
        if isinstance(value, dict):
            row = [rkey] + [str(value.get(k, "")) for k in value.keys() if k != "$type"]
        else:
            # try to convert to dict
            if hasattr(value, "to_dict"):
                value_dict = value.to_dict()
                row = [rkey] + [str(value_dict.get(k, "")) for k in value_dict.keys() if k != "$type"]
            else:
                row = [rkey] + [
                    str(getattr(value, k, ""))
                    for k in dir(value)
                    if not k.startswith("_")
                    and k not in ["py_type", "model_config"]
                    and not callable(getattr(value, k))
                ]

        table.add_row(*row)

    console.print(table)


async def cmd_get(client: AsyncClient, uri: str) -> None:
    """get a specific record."""
    parts = uri.replace("at://", "").split("/")
    if len(parts) != 3:
        console.print(f"[red]error:[/red] invalid URI format: {uri}")
        sys.exit(1)

    repo, collection, rkey = parts

    response = await client.com.atproto.repo.get_record(
        {
            "repo": repo,
            "collection": collection,
            "rkey": rkey,
        }
    )

    table = Table(show_header=False, box=None)
    table.add_column("key", style="cyan")
    table.add_column("value", style="white")

    table.add_row("uri", response.uri)
    table.add_row("cid", response.cid)

    value = response.value
    if isinstance(value, dict):
        for key, val in value.items():
            if key != "$type":
                table.add_row(key, str(val))
    else:
        # try to convert to dict
        if hasattr(value, "to_dict"):
            value_dict = value.to_dict()
            for key, val in value_dict.items():
                if key != "$type":
                    table.add_row(key, str(val))
        else:
            for key in dir(value):
                if (
                    not key.startswith("_")
                    and key not in ["py_type", "model_config"]
                    and not callable(getattr(value, key))
                ):
                    table.add_row(key, str(getattr(value, key, "")))

    console.print(Panel(table, title="[bold]record[/bold]", border_style="dim"))


async def cmd_create(
    client: AsyncClient,
    collection: str,
    record: dict,
) -> None:
    """create a new record."""
    if client.me is None:
        raise ValueError("not authenticated")

    # ensure $type is set
    if "$type" not in record:
        record["$type"] = collection

    # add createdAt if not present
    if "createdAt" not in record:
        record["createdAt"] = datetime.now(UTC).isoformat().replace("+00:00", "Z")

    response = await client.com.atproto.repo.create_record(
        {
            "repo": client.me.did,
            "collection": collection,
            "record": record,
        }
    )

    console.print(
        Panel(
            f"[green]✓[/green] created\n\n[dim]uri:[/dim] {response.uri}\n[dim]cid:[/dim] {response.cid}",
            title=f"[bold]{collection}[/bold]",
            border_style="green",
        )
    )


async def cmd_update(client: AsyncClient, uri: str, updates: dict) -> None:
    """update an existing record."""
    parts = uri.replace("at://", "").split("/")
    if len(parts) != 3:
        console.print(f"[red]error:[/red] invalid URI format")
        sys.exit(1)

    repo, collection, rkey = parts

    # get current
    current = await client.com.atproto.repo.get_record(
        {
            "repo": repo,
            "collection": collection,
            "rkey": rkey,
        }
    )

    # merge
    if isinstance(current.value, dict):
        updated_value = {**current.value, **updates}
    else:
        updated_value = dict(current.value)
        updated_value.update(updates)

    # put
    response = await client.com.atproto.repo.put_record(
        {
            "repo": repo,
            "collection": collection,
            "rkey": rkey,
            "record": updated_value,
        }
    )

    console.print(
        Panel(
            f"[green]✓[/green] updated\n\n[dim]uri:[/dim] {response.uri}\n[dim]cid:[/dim] {response.cid}",
            border_style="green",
        )
    )


async def cmd_delete(client: AsyncClient, uri: str) -> None:
    """delete a record."""
    parts = uri.replace("at://", "").split("/")
    if len(parts) != 3:
        console.print(f"[red]error:[/red] invalid URI format")
        sys.exit(1)

    repo, collection, rkey = parts

    await client.com.atproto.repo.delete_record(
        {
            "repo": repo,
            "collection": collection,
            "rkey": rkey,
        }
    )

    console.print(Panel("[green]✓[/green] deleted", border_style="red"))


def parse_json_args(args: list[str]) -> dict:
    """parse key=value arguments into a dict."""
    result = {}
    for arg in args:
        if "=" not in arg:
            console.print(f"[red]error:[/red] invalid argument format: {arg}")
            console.print("[dim]use key=value format[/dim]")
            sys.exit(1)
        key, value = arg.split("=", 1)
        # try to parse as json primitives
        if value.lower() == "true":
            result[key] = True
        elif value.lower() == "false":
            result[key] = False
        elif value.lower() == "null":
            result[key] = None
        elif value.isdigit():
            result[key] = int(value)
        else:
            try:
                result[key] = float(value)
            except ValueError:
                result[key] = value
    return result


async def main() -> int:
    """main entry point."""
    parser = argparse.ArgumentParser(
        description="atproto record operations",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    # global auth options
    parser.add_argument("--handle", help="atproto handle")
    parser.add_argument("--password", help="atproto password")
    parser.add_argument("--pds", help="pds url (default: https://bsky.social)")

    subparsers = parser.add_subparsers(dest="command", help="command")

    # list
    list_parser = subparsers.add_parser("list", help="list records")
    list_parser.add_argument("collection", help="collection name (e.g., app.bsky.feed.post)")
    list_parser.add_argument("--repo", help="repo DID (default: authenticated user)")
    list_parser.add_argument("--limit", type=int, default=50, help="max records")

    # get
    get_parser = subparsers.add_parser("get", help="get record")
    get_parser.add_argument("uri", help="record AT-URI")

    # create
    create_parser = subparsers.add_parser("create", help="create record")
    create_parser.add_argument("collection", help="collection name")
    create_parser.add_argument(
        "fields",
        nargs="+",
        help="record fields as key=value pairs (e.g., title='My Song' artist='Artist')",
    )

    # update
    update_parser = subparsers.add_parser("update", help="update record")
    update_parser.add_argument("uri", help="record AT-URI")
    update_parser.add_argument(
        "fields", nargs="+", help="fields to update as key=value pairs"
    )

    # delete
    delete_parser = subparsers.add_parser("delete", help="delete record")
    delete_parser.add_argument("uri", help="record AT-URI")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    # update pds if provided
    if args.pds:
        settings.atproto_pds_url = args.pds

    try:
        client = await login(args.handle, args.password)

        if args.command == "list":
            await cmd_list(client, args.collection, args.limit, args.repo)

        elif args.command == "get":
            await cmd_get(client, args.uri)

        elif args.command == "create":
            record = parse_json_args(args.fields)
            await cmd_create(client, args.collection, record)

        elif args.command == "update":
            updates = parse_json_args(args.fields)
            await cmd_update(client, args.uri, updates)

        elif args.command == "delete":
            await cmd_delete(client, args.uri)

        return 0

    except Exception as e:
        console.print(f"[red]error:[/red] {e}")
        if os.getenv("DEBUG"):
            raise
        return 1


if __name__ == "__main__":
    sys.exit(asyncio.run(main()))
