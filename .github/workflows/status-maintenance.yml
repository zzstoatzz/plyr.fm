# status maintenance via claude code
#
# two-phase workflow:
# 1. workflow_dispatch: archives old STATUS.md sections, generates audio, opens PR
# 2. on PR merge: uploads audio to plyr.fm
#
# required secrets:
#   ANTHROPIC_API_KEY - claude code
#   GOOGLE_API_KEY - gemini TTS (for audio generation)
#   PLYR_BOT_TOKEN - plyr.fm developer token (for audio upload)

name: status maintenance

on:
  # TODO: restore schedule after testing
  # schedule:
  #   - cron: "0 9 * * 1" # every monday 9am UTC
  workflow_dispatch:
    inputs:
      skip_audio:
        description: "skip audio generation"
        type: boolean
        default: false
  pull_request:
    types: [closed]
    branches: [main]

jobs:
  # phase 1: archive + generate audio + open PR
  maintain:
    if: github.event_name == 'workflow_dispatch' || github.event_name == 'schedule'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      id-token: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: astral-sh/setup-uv@v4

      - uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          claude_args: |
            --allowedTools "Read,Write,Edit,Bash,Fetch"
          prompt: |
            you are maintaining the plyr.fm (pronounced "player FM") project status file.

            ## critical rules

            1. STATUS.md MUST be kept under 500 lines. this is non-negotiable.
            2. archive content MUST be moved to .status_history/, not deleted
            3. podcast tone MUST be dry, matter-of-fact, slightly sardonic - NOT enthusiastic or complimentary

            ## task 1: gather temporal context

            CRITICAL: you must determine the correct time window by finding when the LAST status maintenance PR was MERGED (not opened).

            run these commands:
            ```bash
            date
            # get the most recently merged status-maintenance PR (filter by branch name, sort by merge date)
            gh pr list --state merged --search "status-maintenance" --limit 20 --json number,title,mergedAt,headRefName | jq '[.[] | select(.headRefName | startswith("status-maintenance-"))] | sort_by(.mergedAt) | reverse | .[0]'
            git log --oneline -50
            ls -la .status_history/ 2>/dev/null || echo "no archive directory yet"
            wc -l STATUS.md
            ```

            determine:
            - what is today's date?
            - when was the last status-maintenance PR MERGED? (use the mergedAt field from the jq output - it's the most recent PR with a branch starting with "status-maintenance-")
            - what shipped SINCE that merge date? (this is your focus window - NOT "last week")
            - does .status_history/ exist? (this implies whether or not this is the first episode)
            - how many lines is STATUS.md currently?

            IMPORTANT: the time window for this maintenance run is from the last merged status-maintenance PR until now. if the last PR was merged on Dec 2nd and today is Dec 8th, you should focus on everything from Dec 3rd onwards, NOT just "the last week".

            ## task 2: archive old sections (MANDATORY if over 250 lines)

            if STATUS.md > 500 lines:
            1. create .status_history/ directory if it doesn't exist
            2. identify section boundaries (look for "---" separators and "### " headers with dates)
            3. move OLDEST sections to .status_history/YYYY-MM.md (grouped by month)
            4. compact the meaning of the original entire STATUS.md into about 500 lines or less
            5. generally preserve the document structure (keep "## recent work" header, "## immediate priorities", etc)
            6. do NOT summarize archived content - move it verbatim and organize it chronologically

            ARCHIVE FILE NAMING - CRITICAL:
            - archive files are organized BY MONTH: .status_history/YYYY-MM.md
            - if today is December 2025, archived December content goes to .status_history/2025-12.md
            - if today is January 2026, archived January content goes to .status_history/2026-01.md
            - check what files already exist in .status_history/ and ADD to the appropriate month file if it exists
            - each month gets ONE file - append to existing month files, don't create duplicates

            so STATUS.md is the living overview, slightly recency biased, but a good general overview of the project.

            .status_history/ is the archive of temporally specific sections of STATUS.md that are worth preserving for historical context, but not significant enough to be stated literally in STATUS.md in perpetuity.

            VERIFY: run `wc -l STATUS.md` after archiving. it MUST be under 500 lines.

            ## task 3: generate audio overview (if skip_audio is false)

            skip_audio input: ${{ inputs.skip_audio }}

            if skip_audio is false:

            ### understand the project first

            before writing the script, read:
            - STATUS.md (the current state)
            - docs/deployment/overview.md if it exists
            - Fetch https://atproto.com/guides/overview to understand ATProto primitives
            - Fetch https://atproto.com/guides/lexicon to understand NSIDs and lexicons
            - fetch and read: https://overreacted.io/open-social/ to understand the vision of open social

            this context helps you explain things accurately, and accessibly without over-simplifying.

            ### determine episode type

            check if .status_history/ directory exists:
            - if NO .status_history/ exists: this is the INAUGURAL episode
            - if .status_history/ exists: this is a SUBSEQUENT episode

            ### write the podcast script

            write to podcast_script.txt with "Host: ..." and "Cohost: ..." lines.

            INAUGURAL EPISODE (ignore this if its not the first episode):
            - introduce what plyr.fm is: decentralized music streaming on ATProto
            - explain the core value prop: your music data lives in your PDS, portable between apps (open social)
            - cover the technical foundation that's been built (summarize from STATUS.md)
            - set expectations: this is an early-stage project, rough edges exist
            - tone: "here's what is being built and why it could matter"
            - work chronologically from beginning to end, don't heavily bias towards nascent or recent work

            SUBSEQUENT EPISODES (ignore this if its the first episode):
            - focus on what actually shipped since the last status-maintenance PR was MERGED
            - use the mergedAt date from task 1 as your starting point, NOT "last week"
            - reference git commits since that merge date to determine what shipped
            - don't re-explain the whole project - listeners already know
            - tone: "here's what changed since last time"

            ### tone requirements (CRITICAL)

            the hosts should sound like two engineers who:
            - are skeptical, amused and somewhat intruiged by the absurdity of building things
            - acknowledge problems and limitations honestly
            - don't over-use superlatives ("amazing", "incredible", "exciting")
            - explain technical concepts through analogy, not hypey jargon

            avoid excessive phrasing:
            - "exciting", "amazing", "incredible", "impressive", "great job"
            - "the team has done", "they've really", "fantastic work"
            - any variation of over-congratulating or over-sensationalizing the project

            pronunciation: "plyr.fm" is pronounced "player FM" (not "plir" or spelled out)

            target length: 2-3 minutes spoken (~300-400 words) (it should be 4-5 if its the first episode)

            ### generate audio

            run: uv run scripts/generate_tts.py podcast_script.txt update.wav
            then: rm podcast_script.txt

            ## task 4: open PR

            if any files changed:
            1. first, generate a unique branch name: BRANCH="status-maintenance-$(date +%Y%m%d-%H%M%S)"
            2. git checkout -b $BRANCH
            3. git add .status_history/ STATUS.md update.wav
            4. git commit -m "chore: status maintenance"
            5. git push -u origin $BRANCH
            6. gh pr create with a title and body you craft:
               - title should be descriptive of what this status update covers (e.g. "chore: status maintenance - playlist fast-follow fixes" or "chore: status maintenance - December updates")
               - make it clear this is an automated status maintenance PR from the GitHub Action
               - body should summarize what changed (archival, audio generation, etc.)

            add a label like "ai-generated" to the PR (create the label if it doesn't exist)
            if nothing changed, report that no maintenance was needed.

        env:
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}

  # phase 2: upload audio after PR merge
  upload-audio:
    if: github.event.pull_request.merged == true && startsWith(github.event.pull_request.head.ref, 'status-maintenance-')
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: astral-sh/setup-uv@v4

      - name: Upload audio to plyr.fm
        run: |
          if [ -f update.wav ]; then
            uv run --with plyrfm -- plyrfm upload update.wav "plyr.fm update - $(date +'%B %d, %Y')" --album "$(date +%Y)" -t ai
          else
            echo "No update.wav found, skipping upload"
          fi
        env:
          PLYR_TOKEN: ${{ secrets.PLYR_BOT_TOKEN }}
